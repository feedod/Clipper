<!DOCTYPE html>
<html lang="ru" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#ffffff">
    <meta name="color-scheme" content="light only">
    <title>Clipper ‚Äî –ó–∞–≥—Ä—É–∑—á–∏–∫ –≤–∏–¥–µ–æ</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <style>
        :root {
            --pico-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif;
            --pico-border-radius: 1rem;
            --pico-spacing: 1.5rem;
        }
        
        html, body {
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .video-container {
            aspect-ratio: 9 / 16;
            max-height: 60vh;
            background: #000;
            border-radius: var(--pico-border-radius);
            overflow: hidden;
        }
        
        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .history-cover {
            width: 5rem;
            height: 5rem;
            object-fit: cover;
            border-radius: 0.75rem;
            flex-shrink: 0;
        }
        
        .spinner {
            animation: spin 1s linear infinite;
            display: inline-block;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            vertical-align: middle;
            margin-right: 0.5rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(1rem); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        [hidden] { display: none !important; }
        
        .quality-grid {
            display: grid;
            gap: 0.75rem;
        }
        
        .quality-grid a[role="button"] {
            margin: 0;
            text-align: center;
        }
        
        .history-item {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .history-meta {
            flex: 1;
            min-width: 0;
        }
        
        .history-meta p {
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .header-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        main {
            padding-bottom: env(safe-area-inset-bottom, 1rem);
        }
    </style>
</head>
<body>
    <main class="container">
        <header>
            <hgroup>
                <h1>üìé Clipper</h1>
                <p>–°–∫–∞—á–∏–≤–∞–π—Ç–µ –≤–∏–¥–µ–æ –∏–∑ Instagram –∏ TikTok –±–µ–∑ –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤</p>
            </hgroup>
        </header>

        <article id="downloadForm">
            <form id="clipperForm">
                <fieldset>
                    <label for="platform">
                        –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
                        <select id="platform" name="platform" required>
                            <option value="" disabled selected>–í—ã–±–µ—Ä–∏—Ç–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É</option>
                            <option value="instagram">üì∑ Instagram</option>
                            <option value="tiktok">üéµ TikTok</option>
                        </select>
                    </label>

                    <label for="videoUrl">
                        –°—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ
                        <input 
                            type="url" 
                            id="videoUrl" 
                            name="url" 
                            placeholder="https://..."
                            autocomplete="off"
                            autocapitalize="off"
                            spellcheck="false"
                            required
                        >
                    </label>
                </fieldset>

                <button type="submit" id="submitBtn">
                    –ü–æ–ª—É—á–∏—Ç—å –≤–∏–¥–µ–æ
                </button>
            </form>

            <p id="errorMessage" role="alert" hidden></p>
        </article>

        <article id="videoResult" class="fade-in" hidden>
            <header>
                <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
            </header>
            
            <div class="grid">
                <div class="video-container">
                    <video id="videoPlayer" controls playsinline webkit-playsinline preload="metadata">
                        –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ.
                    </video>
                </div>
                
                <div>
                    <hgroup>
                        <h4 id="videoTitle">–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞</h4>
                        <p id="videoAuthor"></p>
                    </hgroup>
                    
                    <p id="videoPlatform">
                        <small></small>
                    </p>
                    
                    <div id="qualityButtons" class="quality-grid"></div>
                </div>
            </div>
        </article>

        <section id="historySection" hidden>
            <div class="header-actions">
                <h2>üìú –ò—Å—Ç–æ—Ä–∏—è</h2>
                <button id="clearHistoryBtn" class="outline secondary">
                    –û—á–∏—Å—Ç–∏—Ç—å
                </button>
            </div>
            
            <div id="historyList" class="grid"></div>
        </section>
    </main>

    <script>
    /**
     * ============================================================
     * CONFIGURATION
     * ============================================================
     */
    const CONFIG = Object.freeze({
        HISTORY_KEY: 'clipper_history_v2',
        MAX_HISTORY_ITEMS: 50,
        PLATFORMS: Object.freeze({
            INSTAGRAM: 'instagram',
            TIKTOK: 'tiktok'
        })
    });

    /**
     * ============================================================
     * UTILITY CLASSES
     * ============================================================
     */
    class DOMHelper {
        static $(selector) {
            return document.querySelector(selector);
        }

        static $$(selector) {
            return document.querySelectorAll(selector);
        }

        static show(element) {
            element?.removeAttribute('hidden');
        }

        static hide(element) {
            element?.setAttribute('hidden', '');
        }

        static setError(element, message) {
            if (!element) return;
            
            element.textContent = message;
            element.setAttribute('data-error', '');
            this.show(element);
        }

        static clearError(element) {
            if (!element) return;
            
            element.textContent = '';
            element.removeAttribute('data-error');
            this.hide(element);
        }

        static createElement(tag, attributes = {}, children = []) {
            const element = document.createElement(tag);
            
            Object.entries(attributes).forEach(([key, value]) => {
                if (key === 'className') {
                    element.className = value;
                } else if (key === 'textContent') {
                    element.textContent = value;
                } else if (key === 'innerHTML') {
                    element.innerHTML = value;
                } else if (key.startsWith('data')) {
                    element.setAttribute(key.replace(/([A-Z])/g, '-$1').toLowerCase(), value);
                } else {
                    element.setAttribute(key, value);
                }
            });

            children.forEach(child => {
                if (typeof child === 'string') {
                    element.appendChild(document.createTextNode(child));
                } else if (child instanceof Node) {
                    element.appendChild(child);
                }
            });

            return element;
        }
    }

    class StorageManager {
        static get(key, defaultValue = null) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : defaultValue;
            } catch {
                return defaultValue;
            }
        }

        static set(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
                return true;
            } catch {
                return false;
            }
        }

        static remove(key) {
            try {
                localStorage.removeItem(key);
                return true;
            } catch {
                return false;
            }
        }
    }

    /**
     * ============================================================
     * API CLASSES
     * ============================================================
     */
    class BaseAPI {
        constructor() {
            if (new.target === BaseAPI) {
                throw new Error('BaseAPI is abstract class');
            }
        }

        async fetchVideo(url) {
            throw new Error('Method fetchVideo must be implemented');
        }

        sanitizeUrl(url) {
            return url.trim();
        }

        decodeEscapedUrl(url) {
            return url.replace(/\\u0026/g, '&').replace(/\\\//g, '/');
        }
    }

    class InstagramAPI extends BaseAPI {
        static PROXY_URL = 'https://api.allorigins.win/raw?url=';
        
        static PATTERNS = Object.freeze({
            VIDEO_URL: /"video_url":"([^"]+)"/,
            VIDEO_VERSIONS: /"video_versions":\[([\s\S]*?)\]/,
            DISPLAY_URL: /"display_url":"([^"]+)"/,
            OWNER: /"owner":\{"username":"([^"]+)"/,
            CAPTION: /"edge_media_to_caption":\{"edges":\[\{"node":\{"text":"([^"]*)"/
        });

        async fetchVideo(url) {
            const sanitizedUrl = this.sanitizeUrl(url);
            const proxyUrl = `${InstagramAPI.PROXY_URL}${encodeURIComponent(sanitizedUrl)}`;
            
            const response = await fetch(proxyUrl);
            
            if (!response.ok) {
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É Instagram');
            }

            const html = await response.text();
            return this.parseResponse(html, sanitizedUrl);
        }

        parseResponse(html, originalUrl) {
            const videoUrl = this.extractVideoUrl(html);
            
            if (!videoUrl) {
                throw new Error('–í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –í–æ–∑–º–æ–∂–Ω–æ, —ç—Ç–æ —Ñ–æ—Ç–æ, –∫–∞—Ä—É—Å–µ–ª—å –∏–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –ø–æ—Å—Ç');
            }

            return {
                platform: CONFIG.PLATFORMS.INSTAGRAM,
                originalUrl,
                cover: this.extractCover(html),
                author: this.extractAuthor(html),
                title: this.extractCaption(html),
                qualities: [{ 
                    label: '‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ (–ª—É—á—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ)', 
                    url: videoUrl 
                }],
                previewUrl: videoUrl
            };
        }

        extractVideoUrl(html) {
            const directMatch = html.match(InstagramAPI.PATTERNS.VIDEO_URL);
            
            if (directMatch) {
                return this.decodeEscapedUrl(directMatch[1]);
            }

            const versionsMatch = html.match(InstagramAPI.PATTERNS.VIDEO_VERSIONS);
            
            if (versionsMatch) {
                try {
                    const versions = JSON.parse(`[${versionsMatch[1]}]`);
                    const sorted = versions.sort((a, b) => 
                        (b.height || b.width || 0) - (a.height || a.width || 0)
                    );
                    
                    if (sorted.length > 0) {
                        return this.decodeEscapedUrl(sorted[0].url);
                    }
                } catch {
                    return null;
                }
            }

            return null;
        }

        extractCover(html) {
            const match = html.match(InstagramAPI.PATTERNS.DISPLAY_URL);
            return match ? this.decodeEscapedUrl(match[1]) : '';
        }

        extractAuthor(html) {
            const match = html.match(InstagramAPI.PATTERNS.OWNER);
            return match ? match[1] : '';
        }

        extractCaption(html) {
            const match = html.match(InstagramAPI.PATTERNS.CAPTION);
            return match ? match[1].replace(/\\n/g, ' ').substring(0, 200) : '–ë–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è';
        }
    }

    class TikTokAPI extends BaseAPI {
        static API_URL = 'https://www.tikwm.com/api/';

        async fetchVideo(url) {
            const sanitizedUrl = this.sanitizeUrl(url);
            const apiUrl = `${TikTokAPI.API_URL}?url=${encodeURIComponent(sanitizedUrl)}&hd=1`;
            
            const response = await fetch(apiUrl);
            
            if (!response.ok) {
                throw new Error('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ TikTok');
            }

            const data = await response.json();
            
            if (data.code !== 0) {
                throw new Error(data.msg || '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–∏–¥–µ–æ TikTok');
            }

            return this.parseResponse(data.data, sanitizedUrl);
        }

        parseResponse(videoData, originalUrl) {
            const qualities = this.extractQualities(videoData);
            
            if (qualities.length === 0) {
                throw new Error('–°—Å—ã–ª–∫–∏ –Ω–∞ –≤–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
            }

            return {
                platform: CONFIG.PLATFORMS.TIKTOK,
                originalUrl,
                cover: videoData.cover || '',
                author: videoData.author?.nickname || videoData.author?.unique_id || '',
                title: videoData.title || '–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞',
                qualities,
                previewUrl: videoData.hdplay || videoData.play || videoData.wmplay
            };
        }

        extractQualities(videoData) {
            const qualities = [];
            
            const qualityMap = [
                { key: 'hdplay', label: '‚¨áÔ∏è HD –±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞' },
                { key: 'play', label: '‚¨áÔ∏è –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ' },
                { key: 'wmplay', label: '‚¨áÔ∏è –° –≤–æ–¥—è–Ω—ã–º –∑–Ω–∞–∫–æ–º' }
            ];

            qualityMap.forEach(({ key, label }) => {
                if (videoData[key]) {
                    qualities.push({ label, url: videoData[key] });
                }
            });

            return qualities;
        }
    }

    class APIFactory {
        static #apis = new Map([
            [CONFIG.PLATFORMS.INSTAGRAM, InstagramAPI],
            [CONFIG.PLATFORMS.TIKTOK, TikTokAPI]
        ]);

        static create(platform) {
            const APIClass = this.#apis.get(platform);
            
            if (!APIClass) {
                throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞: ${platform}`);
            }

            return new APIClass();
        }
    }

    /**
     * ============================================================
     * HISTORY MANAGER
     * ============================================================
     */
    class HistoryManager {
        #items = [];
        #maxItems;
        #storageKey;
        #onChangeCallback;

        constructor(storageKey, maxItems = 50) {
            this.#storageKey = storageKey;
            this.#maxItems = maxItems;
            this.#load();
        }

        get items() {
            return [...this.#items];
        }

        get isEmpty() {
            return this.#items.length === 0;
        }

        onChange(callback) {
            this.#onChangeCallback = callback;
        }

        add(video) {
            const existingIndex = this.#items.findIndex(
                item => item.originalUrl === video.originalUrl
            );

            if (existingIndex !== -1) {
                this.#items.splice(existingIndex, 1);
            }

            const historyItem = {
                ...video,
                timestamp: Date.now()
            };

            this.#items.unshift(historyItem);
            this.#items = this.#items.slice(0, this.#maxItems);
            
            this.#save();
            this.#notify();
        }

        clear() {
            this.#items = [];
            StorageManager.remove(this.#storageKey);
            this.#notify();
        }

        #load() {
            this.#items = StorageManager.get(this.#storageKey, []);
        }

        #save() {
            StorageManager.set(this.#storageKey, this.#items);
        }

        #notify() {
            this.#onChangeCallback?.();
        }
    }

    /**
     * ============================================================
     * TELEGRAM WEB APP INTEGRATION
     * ============================================================
     */
    class TelegramIntegration {
        #webApp;
        #isAvailable;

        constructor() {
            this.#webApp = window.Telegram?.WebApp;
            this.#isAvailable = !!this.#webApp;
        }

        get isAvailable() {
            return this.#isAvailable;
        }

        init() {
            if (!this.#isAvailable) return;

            this.#webApp.ready();
            this.#webApp.expand();
            this.#webApp.setHeaderColor('#ffffff');
            this.#webApp.setBackgroundColor('#ffffff');
            
            this.#applyTheme();
        }

        hapticFeedback(type = 'light') {
            if (!this.#isAvailable) return;

            const impact = this.#webApp.HapticFeedback;
            
            switch (type) {
                case 'light':
                    impact?.impactOccurred('light');
                    break;
                case 'medium':
                    impact?.impactOccurred('medium');
                    break;
                case 'success':
                    impact?.notificationOccurred('success');
                    break;
                case 'error':
                    impact?.notificationOccurred('error');
                    break;
            }
        }

        showAlert(message) {
            if (this.#isAvailable) {
                this.#webApp.showAlert(message);
            } else {
                alert(message);
            }
        }

        #applyTheme() {
            document.documentElement.setAttribute('data-theme', 'light');
        }
    }

    /**
     * ============================================================
     * UI RENDERER
     * ============================================================
     */
    class UIRenderer {
        static renderVideoResult(video) {
            const { $ } = DOMHelper;

            $('#videoTitle').textContent = video.title || '–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞';
            $('#videoAuthor').textContent = video.author ? `@${video.author}` : '';
            $('#videoPlatform small').textContent = 
                video.platform === CONFIG.PLATFORMS.INSTAGRAM ? 'üì∑ Instagram' : 'üéµ TikTok';

            const videoPlayer = $('#videoPlayer');
            videoPlayer.src = video.previewUrl;
            videoPlayer.poster = video.cover;

            this.renderQualityButtons(video.qualities, '#qualityButtons');
            
            DOMHelper.show($('#videoResult'));
        }

        static renderQualityButtons(qualities, containerSelector) {
            const container = DOMHelper.$(containerSelector);
            container.innerHTML = '';

            qualities.forEach(quality => {
                const link = DOMHelper.createElement('a', {
                    href: quality.url,
                    role: 'button',
                    download: '',
                    textContent: quality.label
                });
                
                container.appendChild(link);
            });
        }

        static renderHistory(items) {
            const container = DOMHelper.$('#historyList');
            const section = DOMHelper.$('#historySection');

            if (items.length === 0) {
                DOMHelper.hide(section);
                return;
            }

            container.innerHTML = '';

            items.forEach(item => {
                const article = this.createHistoryCard(item);
                container.appendChild(article);
            });

            DOMHelper.show(section);
        }

        static createHistoryCard(item) {
            const platformIcon = item.platform === CONFIG.PLATFORMS.INSTAGRAM ? 'üì∑' : 'üéµ';
            const formattedDate = new Date(item.timestamp).toLocaleString('ru-RU', {
                day: '2-digit',
                month: '2-digit',
                year: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });

            const article = DOMHelper.createElement('article');
            
            article.innerHTML = `
                <div class="history-item">
                    <img 
                        src="${item.cover || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect fill="%23ddd" width="100" height="100"/%3E%3C/svg%3E'}" 
                        alt="–û–±–ª–æ–∂–∫–∞" 
                        class="history-cover"
                        loading="lazy"
                    >
                    <div class="history-meta">
                        <p><strong>${this.escapeHtml(item.title || '–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞')}</strong></p>
                        <p><small>${item.author ? '@' + this.escapeHtml(item.author) : ''}</small></p>
                        <p><small>${platformIcon} ${formattedDate}</small></p>
                    </div>
                </div>
                <div class="quality-grid"></div>
            `;

            const qualityContainer = article.querySelector('.quality-grid');
            
            item.qualities.forEach(quality => {
                const link = DOMHelper.createElement('a', {
                    href: quality.url,
                    role: 'button',
                    className: 'secondary outline',
                    download: '',
                    textContent: quality.label
                });
                qualityContainer.appendChild(link);
            });

            return article;
        }

        static escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        static setLoading(button, isLoading) {
            if (isLoading) {
                button.setAttribute('aria-busy', 'true');
                button.disabled = true;
                button.innerHTML = '<span class="spinner"></span>–ó–∞–≥—Ä—É–∑–∫–∞...';
            } else {
                button.removeAttribute('aria-busy');
                button.disabled = false;
                button.textContent = '–ü–æ–ª—É—á–∏—Ç—å –≤–∏–¥–µ–æ';
            }
        }
    }

    /**
     * ============================================================
     * MAIN APPLICATION
     * ============================================================
     */
    class ClipperApp {
        #telegram;
        #history;
        #elements;

        constructor() {
            this.#telegram = new TelegramIntegration();
            this.#history = new HistoryManager(CONFIG.HISTORY_KEY, CONFIG.MAX_HISTORY_ITEMS);
            this.#cacheElements();
            this.#bindEvents();
            this.#init();
        }

        #cacheElements() {
            this.#elements = {
                form: DOMHelper.$('#clipperForm'),
                platform: DOMHelper.$('#platform'),
                url: DOMHelper.$('#videoUrl'),
                submitBtn: DOMHelper.$('#submitBtn'),
                errorMessage: DOMHelper.$('#errorMessage'),
                videoResult: DOMHelper.$('#videoResult'),
                clearHistoryBtn: DOMHelper.$('#clearHistoryBtn')
            };
        }

        #bindEvents() {
            this.#elements.form.addEventListener('submit', (e) => this.#handleSubmit(e));
            this.#elements.clearHistoryBtn.addEventListener('click', () => this.#handleClearHistory());
            
            this.#history.onChange(() => {
                UIRenderer.renderHistory(this.#history.items);
            });
        }

        #init() {
            this.#telegram.init();
            UIRenderer.renderHistory(this.#history.items);
        }

        async #handleSubmit(event) {
            event.preventDefault();

            const platform = this.#elements.platform.value;
            const url = this.#elements.url.value.trim();

            if (!platform || !url) {
                this.#showError('–í—ã–±–µ—Ä–∏—Ç–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –∏ –≤—Å—Ç–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É');
                return;
            }

            this.#clearError();
            this.#setLoadingState(true);
            DOMHelper.hide(this.#elements.videoResult);

            try {
                const api = APIFactory.create(platform);
                const videoInfo = await api.fetchVideo(url);
                
                UIRenderer.renderVideoResult(videoInfo);
                this.#history.add(videoInfo);
                this.#telegram.hapticFeedback('success');
                
                this.#elements.url.value = '';
                
            } catch (error) {
                this.#showError(error.message || '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ');
                this.#telegram.hapticFeedback('error');
                
            } finally {
                this.#setLoadingState(false);
            }
        }

        #handleClearHistory() {
            this.#history.clear();
            this.#telegram.hapticFeedback('medium');
        }

        #showError(message) {
            DOMHelper.setError(this.#elements.errorMessage, `‚ö†Ô∏è ${message}`);
        }

        #clearError() {
            DOMHelper.clearError(this.#elements.errorMessage);
        }

        #setLoadingState(isLoading) {
            UIRenderer.setLoading(this.#elements.submitBtn, isLoading);
            this.#elements.platform.disabled = isLoading;
            this.#elements.url.disabled = isLoading;
        }
    }

    /**
     * ============================================================
     * INITIALIZATION
     * ============================================================
     */
    document.addEventListener('DOMContentLoaded', () => {
        new ClipperApp();
    });
    </script>
</body>
</html>