<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover"
    />
    <meta name="color-scheme" content="light" />
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.8/dist/cdn.min.js"
    ></script>
    <script
      async
      src="https://plausible.io/js/pa-QR-RoZMy12hrhzIXv4u0Z.js"
    ></script>
    <script>
      window.plausible =
        window.plausible ||
        function () {
          (plausible.q = plausible.q || []).push(arguments);
        };
      plausible.init =
        plausible.init ||
        function (i) {
          plausible.o = i || {};
        };
      plausible.init();
    </script>
    <style type="text/tailwindcss">
      @theme {
        --color-bg: #ffffff;
        --color-surface: #f8f8f8;
        --color-border: #ebebeb;
        --color-text: #000000;
        --color-muted: #8e8e93;
      }

      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      html,
      body {
        background: var(--color-bg);
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
          system-ui, sans-serif;
        overscroll-behavior: none;
        -webkit-font-smoothing: antialiased;
        scrollbar-width: none;
      }

      html::-webkit-scrollbar,
      body::-webkit-scrollbar {
        display: none;
      }

      body {
        padding: env(safe-area-inset-top) env(safe-area-inset-right)
          env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      input {
        font-size: 16px;
        caret-color: #000000;
      }

      input:focus {
        outline: none;
      }

      .press {
        transition: transform 80ms ease, opacity 80ms ease;
      }

      .press:active {
        transform: scale(0.97);
        opacity: 0.8;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .fade {
        animation: fadeIn 0.4s cubic-bezier(0.25, 1, 0.5, 1) both;
      }

      .no-scrollbar {
        scrollbar-width: none;
      }

      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
    </style>
  </head>
  <body
    x-data="App"
    class="flex min-h-dvh flex-col select-none bg-bg text-text"
  >
    <main
      class="mx-auto flex w-full max-w-md flex-1 flex-col overflow-y-auto px-5 pb-32"
    >
      <header class="fade pb-8 pt-10 text-center">
        <h1 class="text-3xl font-bold tracking-tight">Clipper</h1>
        <p class="mt-2 text-sm text-muted" x-text="statusText"></p>
      </header>

      <section class="fade space-y-3" style="animation-delay: 50ms">
        <div class="relative">
          <div
            class="pointer-events-none absolute left-4 top-1/2 -translate-y-1/2"
          >
            <svg
              class="h-5 w-5 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244"
              />
            </svg>
          </div>
          <input
            type="url"
            x-ref="input"
            x-model="url"
            @input.debounce.100ms="detect"
            @paste="$nextTick(() => detect())"
            @keydown.enter.prevent="download"
            :disabled="loading"
            placeholder="Вставьте ссылку на видео"
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            class="h-14 w-full rounded-2xl border border-border bg-surface pl-12 pr-12 text-text transition-colors placeholder:text-muted focus:border-text/20 disabled:opacity-40"
          />
          <button
            x-show="url.length > 0"
            x-transition.opacity.duration.100ms
            @click="clear"
            :disabled="loading"
            aria-label="Очистить поле"
            class="press absolute right-3 top-1/2 grid h-8 w-8 -translate-y-1/2 place-items-center rounded-full bg-border disabled:opacity-40"
            type="button"
          >
            <svg
              class="h-4 w-4 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>

        <button
          x-show="platform && !loading && !video"
          x-transition.opacity.duration.150ms
          @click="download"
          :disabled="loading"
          :style="{ backgroundColor: platform?.colors?.primary }"
          class="press flex h-14 w-full items-center justify-center gap-2.5 rounded-2xl font-semibold text-white disabled:opacity-40"
          type="button"
        >
          <svg
            class="h-5 w-5"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
            />
          </svg>
          <span>Сохранить видео</span>
        </button>
      </section>

      <template x-if="loading">
        <section
          class="fade flex flex-1 flex-col items-center justify-center py-20"
        >
          <div class="mb-6 w-full max-w-60">
            <div class="mb-3 flex items-center justify-between">
              <span class="text-sm font-semibold text-text">Загрузка</span>
              <span
                class="text-sm font-semibold text-text"
                x-text="progress + '%'"
              ></span>
            </div>
            <div
              class="h-2 overflow-hidden rounded-full border border-border bg-surface"
            >
              <div
                class="h-full rounded-full transition-all duration-200 ease-out"
                :style="{ backgroundColor: platform?.colors?.progress, width: progress + '%' }"
              ></div>
            </div>
          </div>
          <p class="text-sm text-muted" x-text="loadingText"></p>
        </section>
      </template>

      <template x-if="error && !loading">
        <section
          class="fade mt-6 rounded-2xl border border-red-100 bg-red-50 p-4"
        >
          <div class="flex items-start gap-3">
            <div
              class="grid h-10 w-10 shrink-0 place-items-center rounded-full bg-red-100"
            >
              <svg
                class="h-5 w-5 text-red-500"
                fill="none"
                stroke="currentColor"
                stroke-width="1.5"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0zm-9 3.75h.008v.008H12v-.008z"
                />
              </svg>
            </div>
            <div class="min-w-0 flex-1 pt-0.5">
              <p class="text-sm font-semibold text-red-600">Ошибка</p>
              <p class="mt-0.5 text-sm text-red-500" x-text="error"></p>
            </div>
          </div>
        </section>
      </template>

      <template x-if="video && !loading">
        <section class="fade mt-6 space-y-4">
          <div
            class="overflow-hidden rounded-2xl border border-border bg-surface"
          >
            <div class="relative h-[56dvh] w-full bg-black">
              <video
                :src="video.play"
                :poster="video.cover"
                class="absolute inset-0 h-full w-full object-contain"
                controls
                playsinline
                webkit-playsinline
              ></video>
              <div
                class="absolute left-3 top-3 flex items-center gap-1.5 rounded-lg bg-white/95 px-2.5 py-1.5 shadow-sm"
              >
                <svg
                  class="h-4 w-4"
                  :style="{ color: platform?.colors?.icon }"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                >
                  <path :d="platform?.icon" />
                </svg>
                <span
                  class="text-xs font-semibold text-text"
                  x-text="platform?.name"
                ></span>
              </div>
              <div
                class="absolute right-3 top-3 flex items-center justify-center rounded-lg bg-white/95 px-2.5 py-1.5 shadow-sm"
              >
                <span
                  class="text-xs font-semibold text-text leading-none"
                  x-text="Formatter.time(video.duration)"
                ></span>
              </div>
            </div>
          </div>

          <button
            @click="openAuthorProfile"
            class="press flex w-full items-center gap-3 rounded-2xl border border-border bg-surface p-4 text-left"
          >
            <img
              :src="video.author?.avatar"
              :alt="video.author?.nickname || 'Автор'"
              @error="$event.target.src = FALLBACK_AVATAR"
              class="h-12 w-12 rounded-full border border-border object-cover"
            />
            <div class="min-w-0 flex-1">
              <p
                class="truncate font-semibold text-text"
                x-text="video.author?.nickname || 'Неизвестный автор'"
              ></p>
              <p
                class="truncate text-sm text-muted"
                x-text="video.author?.unique_id ? '@' + video.author.unique_id : ''"
              ></p>
            </div>
            <svg
              class="h-5 w-5 shrink-0"
              :style="{ color: platform?.colors?.icon }"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path :d="platform?.icon" />
            </svg>
            <svg
              class="h-4 w-4 shrink-0 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="m8.25 4.5 7.5 7.5-7.5 7.5"
              />
            </svg>
          </button>

          <template x-if="video.title">
            <div class="rounded-2xl border border-border bg-surface p-4">
              <div class="mb-2 flex items-center gap-2">
                <svg
                  class="h-4 w-4 text-muted"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.5"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="M7.5 8.25h9m-9 3H12m-9.75 1.51c0 1.6 1.123 2.994 2.707 3.227 1.129.166 2.27.293 3.423.379.35.026.67.21.865.501L12 21l2.755-4.133a1.14 1.14 0 0 1 .865-.501 48.172 48.172 0 0 0 3.423-.379c1.584-.233 2.707-1.626 2.707-3.228V6.741c0-1.602-1.123-2.995-2.707-3.228A48.394 48.394 0 0 0 12 3c-2.392 0-4.744.175-7.043.513C3.373 3.746 2.25 5.14 2.25 6.741v6.018Z"
                  />
                </svg>
                <span class="text-xs font-semibold text-muted uppercase tracking-wide">Описание</span>
              </div>
              <p
                class="text-sm leading-relaxed text-text"
                x-text="video.title"
              ></p>
            </div>
          </template>

          <template x-if="visibleStats.length > 0">
            <div
              class="grid gap-2 rounded-2xl border border-border bg-surface p-3"
              :style="{ gridTemplateColumns: 'repeat(' + visibleStats.length + ', minmax(0, 1fr))' }"
            >
              <template x-for="stat in visibleStats" :key="stat.key">
                <div class="py-2 text-center">
                  <div
                    class="mx-auto grid h-9 w-9 place-items-center rounded-full"
                    :style="{ backgroundColor: platform?.colors?.statsBg }"
                  >
                    <svg
                      class="h-4 w-4"
                      :style="{ color: platform?.colors?.statsIcon }"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="1.5"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        :d="stat.icon"
                      />
                    </svg>
                  </div>
                  <p
                    class="mt-1 text-sm font-semibold text-text"
                    x-text="Formatter.number(video[stat.key])"
                  ></p>
                  <p
                    class="mt-0.5 text-[10px] text-muted"
                    x-text="stat.label"
                  ></p>
                </div>
              </template>
            </div>
          </template>

          <div class="grid grid-cols-2 gap-3 pt-2">
            <button
              @click="saveVideo"
              :style="{ backgroundColor: platform?.colors?.save }"
              aria-label="Сохранить видео"
              class="press flex h-14 items-center justify-center gap-2 rounded-2xl font-semibold text-white"
            >
              <svg
                class="h-5 w-5"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
                />
              </svg>
              <span>Сохранить</span>
            </button>
            <button
              @click="shareStory"
              :style="{ backgroundColor: platform?.colors?.story }"
              aria-label="Поделиться в историю"
              class="press flex h-14 items-center justify-center gap-2 rounded-2xl font-semibold text-white"
            >
              <svg
                class="h-5 w-5"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                />
              </svg>
              <span>В историю</span>
            </button>
          </div>

          <button
            @click="shareLink"
            class="press flex h-14 w-full items-center justify-center gap-2.5 rounded-2xl border border-border bg-surface font-semibold text-text"
          >
            <svg
              class="h-5 w-5 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z"
              />
            </svg>
            <span>Поделиться ссылкой</span>
          </button>
        </section>
      </template>

      <template x-if="!loading && !video">
        <section class="fade mt-8" style="animation-delay: 100ms">
          <div class="mb-4 flex items-center justify-between">
            <div class="flex items-center gap-2">
              <svg
                class="h-5 w-5 text-muted"
                fill="none"
                stroke="currentColor"
                stroke-width="1.5"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                />
              </svg>
              <h2 class="font-semibold text-text">Недавние видео</h2>
            </div>
            <button
              x-show="history.length > 0"
              @click="clearHistory"
              aria-label="Очистить историю"
              class="press text-sm text-muted"
            >
              Очистить
            </button>
          </div>

          <template x-if="history.length === 0">
            <div class="rounded-2xl border border-border bg-surface p-6 text-center">
              <div class="mx-auto mb-4 grid h-14 w-14 place-items-center rounded-full bg-border">
                <svg
                  class="h-7 w-7 text-muted"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.5"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25h-9A2.25 2.25 0 0 0 2.25 7.5v9a2.25 2.25 0 0 0 2.25 2.25Z"
                  />
                </svg>
              </div>
              <p class="font-semibold text-text">История пуста</p>
              <p class="mt-1 text-sm text-muted">Скачайте видео, чтобы оно появилось здесь</p>
            </div>
          </template>

          <template x-if="history.length > 0">
            <div class="no-scrollbar -mx-5 flex gap-3 overflow-x-auto px-5 pb-2">
              <template x-for="item in history" :key="item.id">
                <button
                  @click="loadHistory(item)"
                  aria-label="Загрузить из истории"
                  class="press w-[88px] shrink-0"
                >
                  <div
                    class="relative mb-2 h-[120px] w-[88px] overflow-hidden rounded-xl border border-border"
                  >
                    <img
                      :src="item.cover"
                      alt="Обложка"
                      @error="$event.target.src = FALLBACK_COVER"
                      class="h-full w-full object-cover"
                      loading="lazy"
                    />
                    <div
                      class="absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-black/60 to-transparent"
                    ></div>
                    <div
                      class="absolute bottom-2 left-2 grid h-5 w-5 place-items-center rounded-full bg-white"
                    >
                      <svg
                        class="h-3 w-3"
                        :style="{ color: PlatformRegistry.get(item.platform)?.colors?.icon }"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                      >
                        <path
                          :d="PlatformRegistry.get(item.platform)?.icon"
                        />
                      </svg>
                    </div>
                  </div>
                  <p
                    class="truncate text-left text-xs text-muted"
                    x-text="item.author"
                  ></p>
                </button>
              </template>
            </div>
          </template>
        </section>
      </template>

      <footer
        class="fade mt-auto pt-12"
        style="animation-delay: 150ms"
        x-show="!loading && !video"
      >
        <p class="mb-4 text-center text-sm text-muted">
          Поддерживаемые платформы
        </p>
        <div class="flex flex-wrap justify-center gap-3">
          <template x-for="p in PlatformRegistry.all()" :key="p.name">
            <div
              class="flex items-center gap-2.5 rounded-xl border border-border bg-surface px-5 py-3"
            >
              <svg
                class="h-5 w-5"
                :style="{ color: p.colors?.icon }"
                viewBox="0 0 24 24"
                fill="currentColor"
              >
                <path :d="p.icon" />
              </svg>
              <span
                class="text-sm font-semibold text-text"
                x-text="p.name"
              ></span>
            </div>
          </template>
        </div>
      </footer>
    </main>

    <script>
      const FETCH_TIMEOUT = 15000;
      const PROGRESS_INTERVAL = 100;
      const PROGRESS_STEP_MIN = 2;
      const PROGRESS_STEP_MAX = 10;
      const PROGRESS_LIMIT = 95;
      const BOT_USERNAME = "ClipperAppBot";
      const FALLBACK_AVATAR =
        "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 48 48%22><rect fill=%22%23e5e5e5%22 width=%2248%22 height=%2248%22/></svg>";
      const FALLBACK_COVER =
        "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 88 120%22><rect fill=%22%23e5e5e5%22 width=%2288%22 height=%22120%22/></svg>";

      window.FALLBACK_AVATAR = FALLBACK_AVATAR;
      window.FALLBACK_COVER = FALLBACK_COVER;
      
class URLValidator {
  static isValid(string) {
    try {
      const url = new URL(string);
      return url.protocol === "http:" || url.protocol === "https:";
    } catch {
      return false;
    }
  }
}

      class TelegramBridge {
  static #app = window.Telegram?.WebApp;

  static init() {
    if (!this.#app) return;
    this.#app.ready();
    this.#app.requestFullscreen?.();
    this.#app.disableVerticalSwipes?.();
    this.#app.setHeaderColor?.("#ffffff");
    this.#app.setBackgroundColor?.("#ffffff");
  }

  static get startParam() {
    try {
      return this.#app?.initDataUnsafe?.start_param || null;
    } catch {
      return null;
    }
  }

  static get showPromo() {
    return true;
  }

  static haptic(type = "light") {
    try {
      this.#app?.HapticFeedback?.impactOccurred(type);
    } catch {}
  }

  static notify(type) {
    try {
      this.#app?.HapticFeedback?.notificationOccurred(type);
    } catch {}
  }

  static download(url, filename) {
    try {
      if (!this.#app?.downloadFile) return false;
      this.#app.downloadFile({ url, file_name: filename });
      return true;
    } catch {
      return false;
    }
  }

  static shareStory(mediaUrl, options = {}) {
    try {
      if (!this.#app?.shareToStory) return false;

      const storyParams = this.showPromo
        ? {
            text: options.text || "",
            widget_link: {
              url: `https://t.me/${BOT_USERNAME}`,
              name: "Clipper",
            },
          }
        : {};

      this.#app.shareToStory(mediaUrl, storyParams);
      return true;
    } catch {
      return false;
    }
  }

  static openLink(url) {
    try {
      if (this.#app?.openLink) {
        this.#app.openLink(url);
        return true;
      }
      window.open(url, "_blank");
      return true;
    } catch {
      return false;
    }
  }

  static openTelegramLink(url) {
    try {
      if (this.#app?.openTelegramLink) {
        this.#app.openTelegramLink(url);
        return true;
      }
      window.open(url, "_blank");
      return true;
    } catch {
      return false;
    }
  }

  static shareUrl(url, text = "") {
    try {
      const shareLink = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`;
      
      if (this.#app?.openTelegramLink) {
        this.#app.openTelegramLink(shareLink);
        return true;
      }
      
      if (this.#app?.openLink) {
        this.#app.openLink(shareLink);
        return true;
      }
      
      window.open(shareLink, "_blank");
      return true;
    } catch {
      return false;
    }
  }
}

      class Storage {
        static #KEY = "clipper_history";
        static #MAX = 20;

        static get() {
          try {
            return JSON.parse(localStorage.getItem(this.#KEY)) || [];
          } catch {
            return [];
          }
        }

        static add(item) {
          try {
            const list = this.get().filter((i) => i.id !== item.id);
            list.unshift(item);
            localStorage.setItem(
              this.#KEY,
              JSON.stringify(list.slice(0, this.#MAX))
            );
          } catch {}
        }

        static clear() {
          try {
            localStorage.removeItem(this.#KEY);
          } catch {}
        }
      }

      class Formatter {
        static time(seconds) {
          if (!seconds || isNaN(seconds)) return "0:00";
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, "0")}`;
        }

        static number(num) {
          if (!num || isNaN(num)) return "0";
          if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
          if (num >= 1000) return (num / 1000).toFixed(1) + "K";
          return num.toString();
        }
      }

      class Platform {
        constructor(config) {
          this.name = config.name;
          this.colors = config.colors;
          this.icon = config.icon;
          this.patterns = config.patterns;
          this.stats = config.stats;
          this.authorUrlTemplate = config.authorUrlTemplate;
          this._fetch = config.fetch;
          this._extractId = config.extractId;
          this._buildUrlFromId = config.buildUrlFromId;
        }

        match(url) {
          return this.patterns.some((pattern) => pattern.test(url));
        }

        extractId(url) {
          try {
            if (this._extractId) return this._extractId(url);
            for (const pattern of this.patterns) {
              const match = url.match(pattern);
              if (match?.[1]) return match[1];
            }
            return null;
          } catch {
            return null;
          }
        }

        getAuthorUrl(author) {
          try {
            if (!this.authorUrlTemplate || !author?.unique_id) return null;
            return this.authorUrlTemplate.replace("{username}", author.unique_id);
          } catch {
            return null;
          }
        }

        async fetch(url) {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

          try {
            const data = await this._fetch(url, controller.signal);
            if (!data?.play) throw new Error("Видео недоступно");
            return data;
          } finally {
            clearTimeout(timeout);
          }
        }

        getFilename(video) {
          const id = video?.id || Date.now();
          return `${this.name.toLowerCase()}_${id}.mp4`;
        }

        getShareParam(video, url) {
          try {
            const videoId = video?.id || this.extractId(url);
            if (videoId) {
              return `${this.name.toLowerCase()}_${videoId}`;
            }
            return btoa(url).replace(/[+/=]/g, (c) =>
              c === "+" ? "-" : c === "/" ? "_" : ""
            );
          } catch {
            return null;
          }
        }
        
        buildUrlFromId(id) {
  return `https://vm.tiktok.com/${id}`;
  }
      }

      class PlatformRegistry {
        static #platforms = [];

        static register(config) {
          this.#platforms.push(new Platform(config));
        }

        static detect(url) {
          if (!url) return null;
          return this.#platforms.find((p) => p.match(url)) || null;
        }

        static get(name) {
          if (!name) return null;
          return this.#platforms.find((p) => p.name === name) || null;
        }

        static all() {
          return this.#platforms;
        }

        static parseStartParam(param) {
          try {
            if (!param) return null;

            for (const platform of this.#platforms) {
              const prefix = `${platform.name.toLowerCase()}_`;
              if (param.startsWith(prefix)) {
                const id = param.slice(prefix.length);
                if (id) {
                  return {
                    platform: platform.name,
                    id,
                    url: platform.buildUrlFromId?.(id) || null,
                  };
                }
              }
            }

            const decoded = atob(param.replace(/-/g, "+").replace(/_/g, "/"));
            if (decoded && (decoded.startsWith("http://") || decoded.startsWith("https://"))) {
              const platform = this.detect(decoded);
              return platform
                ? { platform: platform.name, id: null, url: decoded }
                : null;
            }

            return null;
          } catch {
            return null;
          }
        }
      }

      PlatformRegistry.register({
        name: "TikTok",
        colors: {
          primary: "#fe2c55",
          progress: "#000000",
          icon: "#000000",
          save: "#fe2c55",
          story: "#000000",
          statsBg: "#fe2c5520",
          statsIcon: "#fe2c55",
        },
        icon: "M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64c.29 0 .58.04.88.13V9.4c-.29-.03-.6-.05-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4c-.35-.05-.7-.08-1.04-.1z",
patterns: [
  /^https?:\/\/(?:www\.)?tiktok\.com\/@[\w.-]+\/video\/(\d+)/i,
  /^https?:\/\/(?:www\.)?tiktok\.com\/t\/([\w-]+)/i,
  /^https?:\/\/vm\.tiktok\.com\/([\w-]+)/i,
  /^https?:\/\/vt\.tiktok\.com\/([\w-]+)/i,
],
        authorUrlTemplate: "https://www.tiktok.com/@{username}",
        stats: [
          {
            key: "play_count",
            label: "Просмотры",
            icon: "M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347a1.125 1.125 0 0 1 0 1.972l-11.54 6.347a1.125 1.125 0 0 1-1.667-.986V5.653Z",
          },
          {
            key: "digg_count",
            label: "Лайки",
            icon: "M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12Z",
          },
          {
            key: "comment_count",
            label: "Комменты",
            icon: "M12 20.25c4.97 0 9-3.694 9-8.25s-4.03-8.25-9-8.25S3 7.444 3 12c0 2.104.859 4.023 2.273 5.48.432.447.74 1.04.586 1.641a4.483 4.483 0 0 1-.923 1.785A5.969 5.969 0 0 0 6 21c1.282 0 2.47-.402 3.445-1.087.81.22 1.668.337 2.555.337Z",
          },
          {
            key: "share_count",
            label: "Репосты",
            icon: "M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z",
          },
        ],
        extractId(url) {
          const match = url.match(/video\/(\d+)/i);
          return match?.[1] || null;
        },
        buildUrlFromId(id) {
          return `https://www.tiktok.com/@./video/${id}`;
        },
        async fetch(url, signal) {
          const response = await fetch("https://www.tikwm.com/api/", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({ url, hd: 1 }),
            signal,
          });
          if (!response.ok) throw new Error("Ошибка сети");
          const json = await response.json();
          if (json.code !== 0) throw new Error("Видео не найдено");
          return json.data;
        },
      });

      window.Formatter = Formatter;
      window.PlatformRegistry = PlatformRegistry;

      document.addEventListener("alpine:init", () => {
        Alpine.data("App", () => ({
          url: "",
          platform: null,
          loading: false,
          progress: 0,
          video: null,
          error: null,
          history: Storage.get(),
          progressInterval: null,

          get statusText() {
            if (this.loading) return "Загрузка видео...";
            if (this.error) return "Попробуйте другую ссылку";
            if (this.video) return "Видео готово к сохранению";
            if (this.platform) return `${this.platform.name} видео найдено`;
            return "Сохраняйте видео легко и быстро";
          },

          get loadingText() {
            if (this.progress < 30) return "Подключение к серверу...";
            if (this.progress < 60) return "Получение видео...";
            if (this.progress < 90) return "Обработка данных...";
            return "Почти готово...";
          },

          get visibleStats() {
            if (!this.platform?.stats || !this.video) return [];
            return this.platform.stats.filter(
              (stat) =>
                this.video[stat.key] != null && this.video[stat.key] > 0
            );
          },

          init() {
            TelegramBridge.init();
            this.handleStartParam();
          },

          handleStartParam() {
            try {
              const startParam = TelegramBridge.startParam;
              if (!startParam) return;

              const parsed = PlatformRegistry.parseStartParam(startParam);
              if (!parsed) {
                this.error = "Неверная ссылка для скачивания";
                TelegramBridge.notify("error");
                return;
              }

              const platform = PlatformRegistry.get(parsed.platform);
              if (!platform) {
                this.error = "Платформа не поддерживается";
                TelegramBridge.notify("error");
                return;
              }

              if (parsed.url) {
                this.url = parsed.url;
                this.platform = platform;
                this.$nextTick(() => this.download());
              } else if (parsed.id && platform.buildUrlFromId) {
                this.url = platform.buildUrlFromId(parsed.id);
                this.platform = platform;
                this.$nextTick(() => this.download());
              } else {
                this.error = "Не удалось восстановить ссылку";
                TelegramBridge.notify("error");
              }
            } catch (err) {
              this.error = "Ошибка обработки параметров";
              TelegramBridge.notify("error");
            }
          },

detect() {
  this.error = null;
  
  if (!this.url || this.url.trim() === "") {
    this.platform = null;
    this.video = null;
    return;
  }
  
  if (!URLValidator.isValid(this.url)) {
    this.platform = null;
    this.video = null;
    return;
  }
  
  const newPlatform = PlatformRegistry.detect(this.url);
  
  if (!newPlatform) {
    this.platform = null;
    this.video = null;
    return;
  }
  
  this.platform = newPlatform;
  TelegramBridge.haptic("light");
},

          clear() {
            this.url = "";
            this.platform = null;
            this.video = null;
            this.error = null;
            TelegramBridge.haptic("light");
          },

          stopProgress() {
            if (this.progressInterval) {
              clearInterval(this.progressInterval);
              this.progressInterval = null;
            }
          },

          async download() {
            if (!this.platform || this.loading) return;

            this.$refs.input?.blur();
            this.loading = true;
            this.progress = 0;
            this.error = null;
            this.video = null;
            TelegramBridge.haptic("medium");

            this.stopProgress();
            this.progressInterval = setInterval(() => {
              const step =
                Math.floor(Math.random() * (PROGRESS_STEP_MAX - PROGRESS_STEP_MIN + 1)) +
                PROGRESS_STEP_MIN;
              this.progress = Math.min(this.progress + step, PROGRESS_LIMIT);
            }, PROGRESS_INTERVAL);

            try {
              this.video = await this.platform.fetch(this.url);
              this.progress = 100;

              Storage.add({
                id: this.video.id || Date.now(),
                cover: this.video.cover,
                author:
                  this.video.author?.nickname ||
                  this.video.author?.unique_id ||
                  "Неизвестный автор",
                url: this.url,
                platform: this.platform.name,
              });

              this.history = Storage.get();
              TelegramBridge.notify("success");
            } catch (err) {
              if (err.name === "AbortError") {
                this.error = "Превышено время ожидания";
              } else {
                this.error = err.message || "Произошла ошибка";
              }
              TelegramBridge.notify("error");
            } finally {
              this.stopProgress();
              this.loading = false;
            }
          },

          saveVideo() {
            if (!this.video?.play) {
              this.error = "Видео недоступно для скачивания";
              TelegramBridge.notify("error");
              return;
            }

            try {
              const filename = this.platform.getFilename(this.video);
              const success = TelegramBridge.download(this.video.play, filename);

              if (success) {
                TelegramBridge.notify("success");
              } else {
                this.error =
                  "Скачивание видео доступно только в мобильном приложении Telegram";
                TelegramBridge.notify("error");
              }
            } catch (err) {
              this.error = "Ошибка при скачивании видео";
              TelegramBridge.notify("error");
            }
          },

          shareStory() {
            if (!this.video?.play) {
              this.error = "Видео недоступно";
              TelegramBridge.notify("error");
              return;
            }

            try {
              const storyText = this.video.title?.trim()
                ? `${this.video.title.trim()}\n\nСохранено с ${this.platform.name} через @${BOT_USERNAME}`
                : `Сохранено с ${this.platform.name} через @${BOT_USERNAME}`;

              const success = TelegramBridge.shareStory(this.video.play, {
                text: storyText,
              });

              if (success) {
                TelegramBridge.notify("success");
              } else {
                this.error = "Истории доступны только в мобильном Telegram";
                TelegramBridge.notify("error");
              }
            } catch (err) {
              this.error = "Ошибка при публикации истории";
              TelegramBridge.notify("error");
            }
          },

          shareLink() {
  if (!this.platform || !this.video) {
    this.error = "Нет данных для создания ссылки";
    TelegramBridge.notify("error");
    return;
  }

  try {
    const shareParam = this.platform.getShareParam(this.video, this.url);
    
    if (!shareParam) {
      this.error = "Не удалось создать ссылку";
      TelegramBridge.notify("error");
      return;
    }

    const shareUrl = `https://t.me/${BOT_USERNAME}/?startapp=${shareParam}`;
    const shareText = `Скачай это видео с ${this.platform.name} через Clipper!`;

    const success = TelegramBridge.shareUrl(shareUrl, shareText);

    if (success) {
      TelegramBridge.notify("success");
    } else {
      this.error = "Не удалось поделиться ссылкой";
      TelegramBridge.notify("error");
    }
  } catch (err) {
    this.error = "Ошибка при создании ссылки";
    TelegramBridge.notify("error");
  }
},

          openAuthorProfile() {
            if (!this.platform || !this.video?.author) {
              TelegramBridge.haptic("light");
              return;
            }

            try {
              const authorUrl = this.platform.getAuthorUrl(this.video.author);
              
              if (authorUrl) {
                TelegramBridge.openLink(authorUrl);
                TelegramBridge.haptic("light");
              } else {
                TelegramBridge.haptic("light");
              }
            } catch (err) {
              TelegramBridge.haptic("light");
            }
          },

          loadHistory(item) {
            if (!item?.url || !item?.platform) {
              this.error = "Некорректные данные истории";
              TelegramBridge.notify("error");
              return;
            }

            this.url = item.url;
            this.platform = PlatformRegistry.get(item.platform);
            
            if (this.platform) {
              TelegramBridge.haptic("light");
              this.download();
            } else {
              this.error = "Платформа больше не поддерживается";
              TelegramBridge.notify("error");
            }
          },

          clearHistory() {
            Storage.clear();
            this.history = [];
            TelegramBridge.haptic("medium");
          },
        }));
      });
    </script>
  </body>
</html>